# ポインタ
ポインタとはアドレスを格納するための変数である。

## メモリと変数
メモリは０か１かを格納する部品をたくさん持っていて例えるならば、「超巨大な一列ロッカー」のような構造である。
これらのロッカー１つを１ビット、８つをまとめて１バイトと呼んでいる。
メモリにはこの１バイトごとに番号が付けられており区別されている。

変数を宣言すると、メモリ上に一つの塊として領域が確保される。変数の値は、この領域内に２進数で保存される。
また、変数もメモリ上に確保された場所の番号で区別されている。これを変数のアドレスをいう。

##  ポインタ変数
ポインタ変数は、この変数の元となった型の変数のアドレスを自由に代入できる。また、記憶している変数のアドレスを読んだり書き替えたりできる。
int型の変数のアドレスを格納する変数(int型のポインタ変数)は、ポインタ演算子 * を用いて次のように宣言できる。

```
int *p;
int* p;
```

ここで一つ目はポインタ変数は`*p`だと思うかもしれないが実際にはポインタ変数は`p`であって`*p`ではない。

また、複数のポインタ変数を宣言するときは、

`int* p1,p2;`

としてはならない。
こうすると二つ目の`p2`はふつうのint型変数になってしまう。
二つ目もポインタ変数とするには

`int *p1,*p2;`

としなければならない。

## ポインタを扱うときに使う演算子
ポインタを扱うときに用いる演算子としては次の二つがある。

```
&...その変数は格納されているアドレスを示す
*...ポインタが示すアドレスの内容を示す
```

### ポインタを使って代入表示する例

```
int main(void)
{
  int a,b;//定数a,bを定義
  int *p;//ポインタpを定義
  
  //値を代入・表示
  a = 78;
  p = &a;
  
  printf("%d at %p\n",*p,p);
  
  return 0;
}
```

実行結果
`78 at 0x7fff6ec37a84`

このときポインタ変数`p`はアドレスを保持することができる。
このとき、「ポインタ`p`は変数`a`を指している」`p`に保持されている`a`のアドレスをもとに`a`にアクセスすることができる。
上記の場合に、`b = *p`とすると、変数`p`保持しているアドレスの内容を変数`b`に代入する。
このように、変数名`p`no前にポインタ演算子`*`を付けると、`p`が保持しているアドレスの内容(aに78を代入したので78)を意味する。

また`*p = 30`とすると、`p`がさす内容、つまり`a`の値が30となる。ここで、`b`の値は78のまま変わらない。

```
int main(void)
{
  int a,b;//定数a,bを定義
  int *p;//ポインタpを定義
  
  //値を代入・表示
  a = 78;
  p = &a;
  b = *p;
  *p = 30;
  
  printf("%d at %p\n",*p,p);
  printf("%d at %d\n",a,b);
  
  return 0;
}
```

実行結果

```
78 at 0x7fff6ec37a84
30 at 78
```

また上記のプログラム内で`%p`というのがあるがそれは整数を出力するための`%d`と同じようにポインタ(アドレス)を出力する指定子である。
アドレスを`printf()`に渡すにはアドレス演算子`&`を使用する。

これまで`*`という演算子を用いてきたが、

・ポインタ変数`p`を宣言するための`*p`

・`p`の内容を表すための`*p`

という二つの`*`演算子な同じ文字が割り当てられているだけで、まったく違う意味を持つ演算子である。
